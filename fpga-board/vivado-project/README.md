# Jahwa Electronics - Vivado Project Guide
> <div align="justify"> This document covers all the information about the Jahwa Electronics data acquisition system project. It provides step-by-step instructions for creating FPGA designs using Xilinx Vivado.</div>

--------------------------

## :bookmark_tabs: Table of Content

* [Context](#information_source-context)
* [Background](#mag-background)
* [Tools Installation and Configuration](#gear-tools-installation-and-configuration)
* [Creating FPGA Design using Xilinx Vivado](#computer-creating-fpga-design-using-xilinx-vivado)

---------------------------

## :information_source: Context

*Created by*: **Dalta Imam Maulana**
*Document Version*: **September 13th, 2023**

------------------

## :mag: Background

### Xilinx Vivado
<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/vivado-logo.png" alt="vivado-logo" width="40%" />
</p>


Vivado design suite is an integrated design environment (IDE) developed by Xilinx that provides a lot of features such as:

* Vivado high-level synthesis (HLS) compiler transforms C, C++, and SystemC programs into RTL code.
* Vivado simulator that supports mixed-language simulation and verification.
* Vivado IP integrator allows the designer to easily integrate and configure IP cores either a pre-built library from Xilinx or custom-made IP cores.



### Xilinx Vitis

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/vitis-logo.png" alt="vitis-logo" width="60%" />
</p>

Xilinx Vitis is an integrated design environment (IDE) for writing FPGA software. Vitis consists of multiple tools including Xilinx SDK, Vitis High-Level Synthesis (HLS), and SDSoC. The difference between each tool can be explained as follows:

* **Xilinx SDK**: Write application code based on C/C++ to run on a processor in the design that user created in Vivado. The code is usually used to control and configure hardware blocks connected to the processor.
* **Vitis HLS**: Write C/C++ code which then is translated to RTL (Verilog/VHDL) to be used as an IP block in Vivado project. The block generated by Vitis HLS can be loaded in Vivado for manual optimization.
* **Vitis SDSoC**: Write C/C++ code to be built into a block that the tool integrates into a previously created Vivado design. With the SDSoC, the user can accelerate particular data processing functions by building custom hardware blocks without manually designing the hardware block (writing the hardware block using software languages.)



### PYNQ Framework

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pynq-logo.png" alt="pynq-logo" width="55%" />
</p>

PYNQ is an open-source Xilinx framework designed for system designers, software developers, and hardware designers to use Xilinx platforms easily. With the support of Python language and libraries, designers can benefit from using programmable logic and microprocessors to build more exciting and robust embedded systems. The PYNQ framework can now be used with Zynq, Zynq UltraScale+, Zynq RFSoC, and Alveo accelerator boards.

-------------

## :gear: Tools Installation and Configuration

### Installing Xilinx IDE
To install Xilinx IDE, including Vivado and Vitis on your computer, first, you need to download the installer from the Xilinx website. You can download the software through the following link: [**Xilinx Download Page**](https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/vivado-design-tools.html). You can choose either the online or offline installer on the download page. If you select an offline installer, the downloaded software can be used in either Linux or Windows operating systems. 

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/xilinx-download.png" alt="xilinx-download" width="50%" />
</p>
During installation, you need to choose the **Vivado HL Webpack edition** since it doesn't require any license to use the software. If you are using an online installer, please make sure that you have around 40 GB of free space left on your computer since the installer will download a couple of files with a total size of around 35 GB.

> **Please note that different Xilinx tools versions may result in different outputs and have unexpected errors. So, for this project, it is recommended to use Xilinx 2020.2 release.**



### PYNQ Board Setup

To set up the PYNQ board, you need to prepare the following items:

* PYNQ Z1 board
* Computer with browser
* Ethernet cable
* Micro USB cable
* Micro SD with a minimum of 8 GB capacity

After preparing those items, the first thing to do is to download the correct PYNQ image file for the board from the following link [**PYNQ Board File Download Page**](http://www.pynq.io/board.html). For this tutorial, you will use the PYNQ Z1 board from Digilent. So, download the PYNQ image for the PYNQ Z1 board.

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pynq-board-file.png" alt="pynq-board-file" width="50%" />
</p>


After downloading the PYNQ Image, flash the image into the SD card using an OS flasher tool such as **Balena Etcher**. You can download Balena Etcher software from the following link: [**Etcher Download Page**](https://www.balena.io/etcher/). After flashing the PYNQ image to an SD card, you can now try to connect the board to your computer by following the steps below:

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pynq-setup.jpg" alt="pynq-setup" width="50%" />
</p>


1.	Set the JP4 jumper to SD position by placing the jumper over the top two pins as in the figure above.
2.	If you use a micro USB cable to supply power to the board, place the JP5 jumper in a USB position. You can also power the board with a 12 V external power supply by configuring the JP5 jumper to REG position.
3.	Insert the microSD card with the PYNQ image into the micro SD card slot at the bottom of the board.
4.	Connect the micro USB cable to the board and computer.
5.	Connect the board to the network by using an ethernet cable. The connection can be done directly to the computer or via a network router.
6.	Turn on the board and check whether the board is operating correctly by looking at the LED indicator on the board. After turning on the board, the RED LD13 LED will turn on immediately, indicating that the board has power. Shortly after, Yellow LD12 LED will also turn on to show that the board works correctly. After a minute, two BLUE LD4 & LD5 LEDs will start flashing to indicate that the system is now booted and ready to use.
7.	To access the PYNQ board via a direct connection, you must set the IP address of your computer to a static IP address in the range of 192.168.2.00 to 192.168.2.255 (except for 192.168.2.99 since it is used by the board).
8.	After setting the IP address, open the browser and enter **192.168.2.99** in the address bar.
9.	If the board is configured correctly, you will see a login screen with a password field. The username for the board is **xilinx**, and the password is also **xilinx**.

For more detailed information about how the board and how to set it up, you can access the documentation at this link: [**PYNQ Z1 Setup Page**](https://pynq.readthedocs.io/en/latest/getting_started/pynq_z1_setup.html).




--------------------------------



## :computer: Creating FPGA Design using Xilinx Vivado


The following section will guide you on creating an FPGA design capable of sending data to peripheral devices using SPI and I2C protocol and precise trigger signals for external devices. In this design, Microblaze soft processor will be used along with the ARM core to achieve the timing requirements of the project.

### Create New Vivado Project

First, open up the Vivado application and create a new project.

1.	Click next on Create a New Project.
2.	Enter the name of your project, for example, **pynq_jahwa_daq**.
3.	Select RTL project and click next.
4.	You can add Verilog sources in the add source window if you already have Verilog sources. Otherwise, skip the process and click next.
5.	Add board constraint file by choosing **pynq_z1.xdc** file and make sure to check copy constraints files into project option. The board constraint can be downloaded from the following link: [**PYNQ-Z1 Constraint File**](https://reference.digilentinc.com/_media/reference/programmable-logic/pynq-z1/pynq-z1_c.zip).
6.	In the board selection section, choose PYNQ-Z1 board if it is available. Otherwise, you should download the PYNQ-Z1 board file and copy the board files folder to `<Xilinx installation directory>\Vivado\<version>\data\xhub\boards\XilinxBoardStore\boards\Xilinx\`. (Note: for older Vivado versions, you need to copy the board files to `<Xilinx installation directory>\Vivado\<version>\data\boards`). You can download the board file from the following link: [**PYNQ-Z1 Board Files**](https://github.com/cathalmccabe/pynq-z1_board_files/raw/master/pynq-z1.zip).

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pynq-board.png" alt="pynq-board" width="65%" />
</p>


### Add Custom IP to Vivado IP Repository
First, download the custom IP blocks from the [**PYNQ GitHub repository**](https://github.com/Xilinx/PYNQ). You can do this by cloning the repository to your PC or downloading the repository as a zip file. After that, open the IP catalog and add the IP blocks from the PYNQ GitHub repository. The PYNQ IP blocks can be found in **boards/ip** directory inside the PYNQ folder that have been downloaded in the previous step. Note that you should add the entire IP folder instead of individual IP blocks inside the IP folder.

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/ip-repo.png" alt="ip-repo" width="100%" />
</p>


### Create FPGA Design using Block Design Editor

Typically, when crafting FPGA designs, designers usually have to write code using hardware description languages (Verilog/VHDL), a complex and time-consuming task. However, Vivado offers a simpler method through a block diagram approach. This method allows designers to seamlessly combine various IP blocks by visually linking them. Vivado will then automatically create HDL wrapper codes for synthesis, resulting in a bitstream file configuring the FPGA fabric on the selected FPGA board.

For creating the block design for this project, you can use the provided [**tcl script**](https://github.com/kaistseed/jahwa-project/blob/main/fpga-board/vivado-project/jahwa_daq_system/jahwa_daq_system.script/bd_script.tcl) in the repository to automate the block design creation process or do it manually. If you want to use the tcl script, copy the entire code to the tcl console in Vivado, as shown in the figure below.

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/tcl-console.png" alt="tcl-console" width="75%" />
</p>
If you prefer to create the block design manually, you need to create a new one by selecting the **Create Block Design** option in the flow navigator. After that, you must create a design, as shown in the figure below.

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/block-design.png" alt="block-design" width="100%" />
</p>

A detailed explanation of each IP block can be found in the following section.

- #### ZYNQ Processing System

  A processing system is an IP block that connects the processing system (ARM core) and programmable logic (FPGA fabric). This IP block allows you to connect any IP core, either Xilinx IP or custom IP, to the ARM processor. The advantage of connecting the IP blocks to the ARM processor is that the user can easily control the IP operation by writing application software in standard programming languages such as C/C++ or Python instead of hardware description language (Verilog/VHDL). To add processing system IP to the design, you can follow the steps below:

  1. Assuming you already open the block diagram window, you can add the IP core to the design, by clicking **Add IP** button or by using **(Ctrl + I)** keyboard shortcut.

  2. Add **ZYNQ Processing System IP** by entering the zynq keyword on the search bar.

  3. After you add the ZYNQ IP core, you will see a green option window with the **Run Block Automation** text. This block automation option will help you connect the design's IP core. But sometimes, the connection created by this automation process is not correct. So, recheck the connection after performing a block automation operation.

     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/block-automation.png" alt="block-automation" width="80%" />
     </p>

  4. After running block automation, new wires and external interfaces, such as **DDR** and **FIXED_IO,** will appear in the design corresponding to the board output pins.

     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/zynq-bd.png" alt="zynq-bd" width="75%" />
     </p>

  5. The next step is customizing the `ZYNQ Processing System` core to meet the design requirement. For this project, you need to enable **external memory I/O (EMIO)** port. This port will send reset signals to the MicroBlaze soft processor. In addition, **interrupt** ports also need to be enabled so that the ARM processor can receive interrupt signals from the MicroBlaze soft processor. The configuration details can be seen in the figure below.

     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/zynq-config.png" alt="zynq-bd" width="100%" />
     </p>

  

- #### AXI GPIO

  AXI GPIO is a Xilinx IP block that provides an interface between the general-purpose input/output port (GPIO) and the AXI bus. This IP is needed because ARM processors can only communicate with other IP blocks using the AXI protocol. The AXI GPIO IP will translate the signal coded in the AXI protocol to the standard I/O protocol. In this project, you need to add 5 AXI GPIO blocks to control external ADC, external DAC, and onboard LED. The configuration details for the IP can be seen in the table below.

  | Component Name | I/O Width | Dual Channel | I/O Direction | Port Name                    | Details                                                      |
  | -------------- | --------- | ------------ | ------------- | ---------------------------- | ------------------------------------------------------------ |
  | axi_gpio_0     | 4         | No           | Output        | PYNQ_MB_DEBUG                | Control onboard LEDs                                         |
  | axi_gpio_1     | 1         | No           | Output        | PYNQ_CNV                     | Control ADC power                                            |
  | axi_gpio_2     | 1         | No           | Output        | PYNQ_SDN1                    | Control LDO 1 power                                          |
  | axi_gpio_3     | 1         | No           | Output        | PYNQ_SDN2                    | Control LDO 2 power                                          |
  | axi_gpio_4     | 1         | No           | Output        | PYNQ_SDN3                    | Control LDO 3 power                                          |
  | axi_gpio_5     | 1         | Yes          | Output        | GPIO1: REL1<br />GPIO2: REL2 | Control relay for switching between <br />static and active measurement |
  
  To configure the IP, double click the IP and choose the IP configuration tab. In the IP configuration section, you must check the **All Outputs** option and set the GPIO width accordingly.
  
  <p align="center">
      <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/axi-gpio-config.png" alt="axi-gpio-config" width="60%" />
  </p>
  
  After configuring every AXI GPIO IP, you need to connect the output of the IP with a port. You can create a port by **right click** on the block diagram window and selecting **create interface port**. A new window will appear, and you can search for GPIO.
  
  <p align="center">
      <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/gpio-port.png" alt="gpio-port" width="35%" />
  </p>
  
  
- #### AXI Quad SPI

  The AXI Quad SPI IP block connects the AXI Interface to external SPI devices. This IP block support standard, dual, or quad SPI protocol instruction set. For this project, the AXI Quad SPI block is used to configure the output voltage of the LDO, configure the external ADC, and get the output value of the external ADC. The configuration details for the SPI IP block can be seen in the figure below. 
  
  <p align="center">
      <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/spi-config.png" alt="spi-config" width="75%" />
  </p>
In the figure above, the transaction width is set to a 16-bit packet since both ADC and LDO communicate to the SPI master by sending data in 16-bit chunks. As for the SPI transaction speed, it is set to 25 MHz by configuring the frequency ratio to 4 since the main system clock is set to 100 MHz. After adding the SPI IP block, connect the SPI block output to the interface port in the block diagram.



- #### AXI IIC

  The AXI IIC IP block connects the AXI interface and external devices using a low-speed, two-wire IIC interface. In this project, an IIC interface is needed so that the FPGA can communicate with the Meissner sensor. The configuration detail of the AXI IIC can be seen in the figure below.

  <p align="center">
      <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/iic-config.png" alt="iic-config" width="75%" />
  </p>
  In the configuration above, the IIC clock speed is set to the maximum clock speed at 1 MHz. In addition, the Meissner sensor uses a low state as an active data signal. So, the active state of the SDA is set to 0. After adding the IIC IP block, connect the IIC block output to the interface port in the block diagram.



- #### AXI Clock Divider

  AXI clock divider is a custom AXI IP block used to generate a triggering signal for the laser trigger. The frequency can be any frequency that is multiple of the main clock signal, and the trigger signal frequency can be changed during runtime by writing the division ratio to the register inside the IP block. The steps to create the AXI clock divider are described below:

  1. Go to **Tools** menu and click **Create and Package New IP**.
  
  2. Select **Create AXI4 Peripheral**.
  
  3. Give a name to the IP core and set the directory for storing the IP core-related files.
  
  4. In the next window, it will show a default module that has a single AXI4-LITE Slave Interface. You can add another AXI interface to the IP core. But, for this specific project, a **single AXI4-LITE Slave Interface** with a **data width of 32 bits** and **8 registers** is enough.
  
     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/axi-clkdiv-port.png" alt="axi-clkdiv-port" width="60%" />
     </p>
  
  5. At the next window, you will edit the IP core immediately. So, select **Edit IP** option and it will take you to the IP editor window.
  
  6. At the editor window, navigate to the source menu and double-click on the inner file (the one with `S00_AXI_inst`). This Verilog file contains all of the AXI-LITE timing and state machine template. So, you only need to add your logic to interact with this AXI interface.
  
     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/axi-clkdiv-window.png" alt="axi-clkdiv-window" width="100%" />
     </p>
  
  7. This custom IP block will take the **input clock signal** and generate the **output trigger signal** based on the **division ratio** and the **number of trigger signal** parameters that are written to the AXI slave register by the user. The frequency of the **output trigger signal** is obtained by dividing the **input clock signal** frequency by the **division ratio**. Please note that this IP block only supports a division ratio that is an even number. The **number of trigger signal** parameter determines how many pulses that are generated by the clock divider. The overall clock divider block scheme is described in the simulation waveform below.
  
     <p align="center">
         <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/axi-clkdiv-sim.png" alt="axi-clkdiv-sim" width="100%" />
     </p>	
  
     In the waveform above, four pulses of output trigger signal are generated when the **division ratio** is set to 2 and the **number of trigger signal** parameter is set to **4**. Meanwhile, when the user sets the **division ratio** to **4**, and the number of trigger signal parameter is set to **10**, 10 pulses of 25 MHz signal are produced.
  
  8. The verilog code for the clock divider is provided below.
  
     ```verilog
     module clock_divider
         //////////////////////////////////////////////////////////////////////
         //              Module Parameters and Ports Declaration             //
         //////////////////////////////////////////////////////////////////////
         (
             // Global control signals
             input wire I_CLK,
             input wire I_RSTn,
     
             // Input data
             input wire I_START,
             input wire [31:0] I_DIV_FACTOR,
             input wire [31:0] I_ACTIVE_COUNT,
             
             // Output clock
             output wire O_CLK_DIV,
             output wire [31:0] O_ACTIVE_COUNT
         );
     
         //////////////////////////////////////////////////////////////////////
         //                    Internal Register Declaration                 //
         //////////////////////////////////////////////////////////////////////
         reg r_clk_div;
         reg r_clk_div_out;
         reg [31:0] r_div_count;
         reg [31:0] r_active_count;
     
         //////////////////////////////////////////////////////////////////////
         //                            Main Logic                            //
         //////////////////////////////////////////////////////////////////////
         // Counter logic
         always @(posedge I_CLK or negedge I_RSTn or negedge I_START)
         begin
             if (!I_RSTn || !I_START)
             begin
                 r_div_count <= 0;
             end
             else
             begin
                 if (I_START)
                 begin
                     if (r_div_count < I_DIV_FACTOR-1)
                     begin
                         r_div_count <= r_div_count + 1;
                     end
                     else
                     begin
                         r_div_count <= 0;
                     end
                 end
                 else
                 begin
                     r_div_count <= r_div_count;
                 end
             end
         end
     
         // Clock divider logic
         always @(posedge I_CLK or negedge I_RSTn)
         begin
             if (!I_RSTn)
             begin
                 r_clk_div <= 0;
             end
             else
             begin
                 if (r_div_count <= (I_DIV_FACTOR/2)-1)
                 begin
                     r_clk_div <= 0;
                 end
                 else
                 begin
                     r_clk_div <= 1;
                 end
             end
         end
     
         // Active count logic
         always @(posedge r_clk_div or negedge I_RSTn or negedge I_START)
         begin
             if (!I_RSTn || !I_START)
             begin
                 r_active_count <= 0;
             end
             else
             begin
                 if (I_START)
                 begin
                     if (r_active_count < I_ACTIVE_COUNT+1)
                     begin
                         r_active_count <= r_active_count + 1;
                     end
                     else
                     begin
                         r_active_count <= r_active_count;
                     end
                 end
                 else
                 begin
                     r_active_count <= r_active_count;
                 end
             end
         end
     
         // Generate clock divider output that is active when I_START is high
         always @(posedge I_CLK or negedge I_RSTn)
         begin
             if (!I_RSTn)
             begin
                 r_clk_div_out <= 0;
             end
             else
             begin
                 if (r_active_count < I_ACTIVE_COUNT+1)
                 begin
                     r_clk_div_out <= r_clk_div;
                 end
                 else
                 begin
                     r_clk_div_out <= 0;
                 end
             end
         end
     
         assign O_CLK_DIV = r_clk_div_out & I_START;
         assign O_ACTIVE_COUNT = r_active_count;
     
     endmodule
     ```
  
  9. In order to integrate the **clock_divider** module into AXI IP core, while in the IP editor, create a new source by using **Add Sources** button and create a new Verilog file that contains the **clock_divider** Verilog code above.
  
  10. After that, instantiate the **clock_divider** instance inside the AXI template Verilog file . You can instantiate the **clock_divider** module by copying the code below on the area below the **Add user logic here**. Things to note that in the module instantiation, the **start signal** is connected to **slv_reg0**, **division factor** to **slv_reg1**, and **active count** to **slv_reg2** of the AXI module. So, every change in those register values will be seen by the clock divider module.
  
      ```verilog
      // Add user logic here
      // Declare local wire
      wire w_i_start;
      wire [31:0] w_i_div_factor;
      wire [31:0] w_i_active_count;
      wire [31:0] w_o_active_count;
      
      // Assing value to local wire
      assign w_i_start = slv_reg0[0];
      assign w_i_div_factor = slv_reg1;
      assign w_i_active_count = slv_reg2;
      
      // Instantiate clock divider module
      clock_divider clock_divider_inst
      (
          // Global control signals
          .I_CLK(S_AXI_ACLK), // Input clock signal
          .I_RSTn(S_AXI_ARESETN),
      
          // Input data
          .I_START(w_i_start), // Start signal to generate output trigger signal
          .I_DIV_FACTOR(w_i_div_factor), // Division ratio
          .I_ACTIVE_COUNT(w_i_active_count), // Number of output trigger signal
      
          // Output clock
          .O_CLK_DIV(O_CLK_DIV), // Output trigger signal
          .O_ACTIVE_COUNT(w_o_active_count) // Number of output trigger signal
      );
      // User logic ends
      ```
  
  11. Inside the AXI template Verilog file (the one with **S00_AXI_inst**), you need to add module port for the **O_CLK_DIV** signal. This is needed so that you can map this signal to a specific pin in the PYNQ board. To add the port, add the code below on top of the AXI template Verilog file, below the users to add ports here comment.
  
      ```verilog
      // Users to add ports here
      output wire O_CLK_DIV,
      
      // User ports ends
      // Do not modify the ports beyond this line
      ```
  
  12. You also need to add the **O_CLK_DIV** port in the top Verilog module (the one without **S00_AXI_inst** name). Otherwise, the O_CLK_DIV signal won't be visible when you add this custom IP block in the block diagram. In addition, you need to edit the AXI template Verilog file (the one with **S00_AXI_inst**) module instantiation since you add an additional port in the previous step. To do it, replace the code below instantiation of the AXI bus interface S00_AXI comment with the code below.
  
      ```verilog
      // Instantiation of Axi Bus Interface S00_AXI
      axi_clock_divider_v1_0_S00_AXI # ( 
          .C_S_AXI_DATA_WIDTH(C_S00_AXI_DATA_WIDTH),
          .C_S_AXI_ADDR_WIDTH(C_S00_AXI_ADDR_WIDTH)
      ) axi_clock_divider_v1_0_S00_AXI_inst (
          .S_AXI_ACLK(s00_axi_aclk),
          .S_AXI_ARESETN(s00_axi_aresetn),
          .S_AXI_AWADDR(s00_axi_awaddr),
          .S_AXI_AWPROT(s00_axi_awprot),
          .S_AXI_AWVALID(s00_axi_awvalid),
          .S_AXI_AWREADY(s00_axi_awready),
          .S_AXI_WDATA(s00_axi_wdata),
          .S_AXI_WSTRB(s00_axi_wstrb),
          .S_AXI_WVALID(s00_axi_wvalid),
          .S_AXI_WREADY(s00_axi_wready),
          .S_AXI_BRESP(s00_axi_bresp),
          .S_AXI_BVALID(s00_axi_bvalid),
          .S_AXI_BREADY(s00_axi_bready),
          .S_AXI_ARADDR(s00_axi_araddr),
          .S_AXI_ARPROT(s00_axi_arprot),
          .S_AXI_ARVALID(s00_axi_arvalid),
          .S_AXI_ARREADY(s00_axi_arready),
          .S_AXI_RDATA(s00_axi_rdata),
          .S_AXI_RRESP(s00_axi_rresp),
          .S_AXI_RVALID(s00_axi_rvalid),
          .S_AXI_RREADY(s00_axi_rready),
          // User defined ports
          .O_CLK_DIV(O_CLK_DIV)
      );
      ```
  
  13. The next step is to package the newly created custom AXI IP core that you have made. This can be done by looking at the **Packaging Steps** tab in the IP Editor window. In the **Packaging Steps,** you need to ensure that all of the tabs have green checkmarks. Otherwise, you need to resolve those issues by clicking on the unchecked tab and clicking on the text with blue color and yellow background. For example, in the **Customization Parameters** tab, you need to click **Merge Changes from Customization Parameters Wizard** text to resolve the issue. After that, you can repackage the IP by clicking on **Review and Package** tab and click the **Re-Package IP** button.
  
      <p align="center">
          <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/ip-repackaging.png" alt="ip-repackaging" width="100%" />
      </p>	
  
  14. If there are no errors in the design, you will be asked if you want to return to your main project. You need to click **OK** to exit IP editor. Upon exit, you need to upgrade the IP block by first clicking the **report IP status** on the block diagram editor. After that, click the **Upgrade Selected** button on the IP status window. Make sure that the clock divider IP checkbox is checked before upgrading the IP.
  
      <p align="center">
          <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/ip-upgrade.png" alt="ip-upgrade" width="90%" />
      </p>	
  
     15. The last step is to add the IP to the block diagram and connect the output of the clock divider IP to the external port. Since the output port is not a standard interface port. Instead of choosing **create interface port** option in the right-click menu, you need to choose **create port** option. In the create port window, you only need to give the port name and set the direction to **output**.
  
         <p align="center">
             <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/clkdiv-port.png" alt="clkdiv-port" width="40%" />
         </p>
         
         

- #### MicroBlaze Soft Processor Subsystem

  MicroBlaze IP is a soft processor core from Xilinx based on RISC architecture.  This IP core supports 3-stage pipeline architecture for the optimal area and a 5-stage pipeline for maximum performance. AXI protocol is used as an interface to other IP blocks in the design. In this project, the data acquisition operation (reading data from ADC and Meissner sensor) is timing-critical (low latency and precise timing delay). While the ARM core can control the SPI and IIC IP operation, the data transfer latency and timing delay is not accurate due to the ARM core running a Linux operation system, which is not deterministic by nature. Thus, a barebone MicroBlaze processor is used in this project to control the timing-critical operation of the data acquisition system, such as reading and writing to the external device, and the ARM core will run application code that communicates with the PC client and send instructions to the MicroBlaze processor based on the data received from the client. 

  To add MicroBlaze soft processor to the design, first you need to create a MicroBlaze subsystem which consists of the following IP blocks:

  - MicroBlaze Core
  - AXI BRAM Controller
  - Processor System Reset
  - Local Memory Block (BRAM)
  - AXI Interrupt Controller
  - AXI GPIO for interrupt control
  - AXI Timer (delay timer)
  - Reset Vector (from PYNQ repository)
  - AXI Interconnect (for connecting MicroBlaze and peripheral IP block)

  The design of the MicroBlaze soft processor subsystem can be seen in the figure below. Since the design is complicated, you can automatically create the MicroBlaze subsystem by pasting the [**tcl script**](https://github.com/kaistseed/jahwa-project/blob/main/fpga-board/vivado-project/jahwa_daq_system/jahwa_daq_system.script/microblaze.tcl) to the Vivado tcl console.

  <p align="center">
      <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/mb-softprocessor.png" alt="mb-softprocessor" width="100%" />
  </p>

  One important thing in the MicroBlaze subsystem design above is that there are three AXI Timer instances with the function of each timer are explained below:

  - **AXI Timer 0**: background timer that can be used independently from other timers. This project uses this timer to realize the background timer for **write_interval_us**.
  - **AXI Timer 1**: this timer is configured as two 32-bit counters to generate delay in the Vitis C/C++ program. In this project, the delay function can be used to realize **measure_interval_us** and **delay_from_write_to_measure_us**.
  - **AXI Timer 2**: used as a global counter in Vitis C/C++ program for measuring function or program runtime. This timer is configured as a single 64-bit counter. 



### Edit Memory Address Mapping

After creating the top block design, you need to edit the memory address mapping in the address editor. The memory address mapping will determine the size of BRAM that is used as a shared memory between MicroBlaze and ARM core. In addition, other peripheral IP blocks such as AXI IIC and AXI quad SPI need to have dedicated memory addresses so that both MicroBlaze and ARM core can control the operation of those IPs. The full memory address configuration for this project can be seen in the table below.

| Name                                                         | Interface | Master Base Address | Range |
| ------------------------------------------------------------ | --------- | ------------------- | ----- |
| axi_clock_divider_0/S00_AXI                                  | S00_AXI   | 0x4000_2800         | 1K    |
| axi_gpio_0/S_AXI                                             | S_AXI     | 0x4000_0000         | 1K    |
| axi_gpio_1/S_AXI                                             | S_AXI     | 0x4000_0400         | 1K    |
| axi_gpio_2/S_AXI                                             | S_AXI     | 0x4000_0800         | 1K    |
| axi_gpio_3/S_AXI                                             | S_AXI     | 0x4000_0C00         | 1K    |
| axi_gpio_4/S_AXI                                             | S_AXI     | 0x4000_1000         | 1K    |
| axi_gpio_5/S_AXI                                             | S_AXI     | 0x4000_2C00         | 1K    |
| axi_iic_0/S_AXI                                              | S_AXI     | 0x4080_0000         | 64K   |
| axi_quad_spi_0/AXI_LITE                                      | AXI_LITE  | 0x4081_0000         | 64K   |
| mb_softprocessor_0/axi_gpio_0/S_AXI                          | S_AXI     | 0x4000_2400         | 1K    |
| mb_softprocessor_0/axi_intc_0/S_AXI                          | s_axi     | 0x4000_1400         | 1K    |
| mb_softprocessor_0/axi_timer_0/S_AXI                         | S_AXI     | 0x4000_1800         | 1K    |
| mb_softprocessor_0/axi_timer_1/S_AXI                         | S_AXI     | 0x4000_1C00         | 1K    |
| mb_softprocessor_0/axi_timer_2/S_AXI                         | S_AXI     | 0x4000_2000         | 1K    |
| mb_softprocessor_0/microblaze_local_memory_0/ilmb_bram_ctrl_0/SLMB | SLMB      | 0x0000_0000         | 512K  |
| mb_softprocessor_0/microblaze_local_memory_0/ilmb_bram_ctrl_0/SLMB1 | SLMB1     | 0x0000_0000         | 512K  |
| axi_intc_0/S_AXI                                             | s_axi     | 0x4180_0000         | 64K   |
| mb_softprocessor_0/axi_bram_ctrl_0/S_AXI                     | S_AXI     | 0x4000_0000         | 512K  |

The detail of the address spaces that are used by ARM and MicroBlaze Processor can be found in the figure below.

<p align="center">
    <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/address-editor.png" alt="address-editor" width="100%" />
</p>


### Synthesizing Design and Edit Board Pin Mapping

After you have created the top design and edited the memory address mapping, the next step is to synthesize the design and edit the board pin mapping before you can generate the bitstream for the FPGA. In order to synthesize the design, you can follow the steps below:

1. Validate the block design by clicking the **validate design** button at the top of the diagram window (a square with a checkmark symbol). This process will perform a sanity check of your system and flag any potential problems in the design, such as unconnected wires, incompatible pins, etc. For this project, if you get a warning related to the clock and reset signal, you can ignore it. But, if there are any other warnings or errors after design validation, you need to fix the problem in the design.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/validate-design.png" alt="validate-design" width="100%" />
   </p>

2. After validating the design, under the `Sources` menu, right-click on the block diagram file (file with .bd extension), and click  **Create HDL Wrapper** option. For the sake of simplicity, let Vivado manage and automatically update the design. The **Create HDL Wrapper** process will create a high-level Verilog file representing your block diagram.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/hdl-wrapper.png" alt="hdl-wrapper" width="100%" />
   </p>

3. If there are no errors, you can start synthesizing the design by clicking the **run synthesis** option under the synthesis menu in the flow navigator. After clicking the **run synthesis** button, a new window will appear in which you can choose how many jobs (CPU cores) you would use for the synthesis process. The synthesis process may take a couple of minutes, depending on the number of jobs you use and the design complexity. Errors may appear during this process. So, pay attention and fix it by checking the error message in the tcl console or log windows at the bottom of Vivado.

4. After the synthesis process is complete, you need to change the board pin mapping. This step is necessary so that the interface port such as SPI and IIC ports are mapped to the correct pin in the PYNQ board. The pin mapping can be changed by clicking **open synthesis design** in the flow navigator and after the design opens, click **window** and then **I/O ports** option from the toolbar.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/pin-mapping.png" alt="pin-mapping" width="100%" />
   </p>

   In the I/O ports menu, you need to change board pin mapping as follows:

   |       Port Name        | Package Pin Name |  I/O Std  |
   | :--------------------: | :--------------: | :-------: |
   |     PYNQ_CNV_tri_o     |       V17        | LVCMOS33* |
   | PYNQ_MB_DEBUG_tri_o[3] |       M14        | LVCMOS33* |
   | PYNQ_MB_DEBUG_tri_o[2] |       N16        | LVCMOS33* |
   | PYNQ_MB_DEBUG_tri_o[1] |       P14        | LVCMOS33* |
   | PYNQ_MB_DEBUG_tri_o[0] |       R14        | LVCMOS33* |
   |       IIC_scl_io       |       P16        | LVCMOS33* |
   |       IIC_sda_io       |       P15        | LVCMOS33* |
   |    PYNQ_SDN1_tri_o     |       U17        | LVCMOS33* |
   |    PYNQ_SDN2_tri_o     |       R16        | LVCMOS33* |
   |    PYNQ_SDN3_tri_o     |       T15        | LVCMOS33* |
   |      SPI_ss_io[1]      |       T16        | LVCMOS33* |
   |      SPI_ss_io[0]      |       V18        | LVCMOS33* |
   |       SPI_io0_io       |       R17        | LVCMOS33* |
   |       SPI_io1_io       |       P18        | LVCMOS33* |
   |       SPI_sck_io       |       N17        | LVCMOS33* |
   |          TRIG          |       V15        | LVCMOS33* |
   |       REL1_tri_o       |       V13        | LVCMOS33* |
   |       REL2_tri_o       |       U13        | LVCMOS33* |
   
   After changing the pin mapping, save the constraint, and resynthesize the design.



### Generating Bitstream and Exporting Hardware Design

After finish configuring the pin mapping, you can start generating bitstream for configuring the FPGA board by following the steps below:

1. You can generate the bitstream for the FPGA board by clicking **Generate Bitstream** option under the **Program and Debug** menu in Flow navigator. Choosing **Generate Bitstream** option will start the whole build process from the module synthesizing process up to generating the output bitstream product. This process may take a couple of minutes, depending on your computer and design complexity. Errors may appear during this process. So, pay attention to it and try to fix the error if there is an error in your design.

2. When the build is complete, you need to export the bitstream file by choosing **Export Bitstream File** option under the **Export** option under **File** menu. Ensure your block diagram window is open before exporting the block diagram. Otherwise, the **Export Bitstream File** option will not show up. Make sure to name the bitstream file (file with .bit extension) with the block design name (by default, it is design_1). Otherwise, an error message will appear when you load the design into the PYNQ board. You should also generate a tcl file for configuring the FPGA board by choosing **Export Block Design** option. 

3. The next step is to generate a hardware design file for Vitis. This hardware design file will be used to create firmware for the Microblaze softprocessor. To export the hardware design file, you can click **Export Hardware**, and after that, a new window will appear. In this window, you need to choose **include bitstream** option. Otherwise, the Vitis won't generate the firmware for the Microblaze properly.

   <p align="center">
       <img src="https://github.com/kaistseed/jahwa-project/blob/c578709a7fe9241e3b1350e436c54a0bcc80bf08/documentation/resources/generate-bitstream.png" alt="generate-bitstream" width="100%" />
   </p>
